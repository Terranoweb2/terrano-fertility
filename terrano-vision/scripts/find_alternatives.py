#!/usr/bin/env python3
"""
Script de recherche d'alternatives pour cha√Ænes non fonctionnelles
Focus: Contenu de divertissement mature mais appropri√©
"""

import requests
import json
import time
from typing import List, Dict
import re

class AlternativeChannelFinder:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
        print("=" * 80)
        print("üîÑ RECHERCHE D'ALTERNATIVES - CHA√éNES NON FONCTIONNELLES")
        print("=" * 80)
        print("üéØ Focus: Contenu divertissement mature mais appropri√©")
        print("‚úÖ Remplacement des cha√Ænes d√©faillantes")
        print("=" * 80)
        print()
    
    def get_non_functional_channels(self) -> List[Dict]:
        """Liste des cha√Ænes non fonctionnelles √† remplacer"""
        return [
            {
                'name': 'FilmRise Hot Ones (720p)',
                'category': 'Culinaire/Divertissement',
                'quality': '720p',
                'type': '√âmission culinaire avec c√©l√©brit√©s',
                'target_audience': 'Jeunes adultes',
                'replacement_keywords': ['cooking', 'celebrity', 'food', 'entertainment']
            },
            {
                'name': 'Hot Ones (duplicatas)',
                'category': 'Culinaire/Divertissement', 
                'quality': 'SD',
                'type': '√âmission culinaire populaire',
                'target_audience': 'Tout public',
                'replacement_keywords': ['cooking', 'food', 'talk show', 'celebrity']
            },
            {
                'name': 'Shots! (1080p)',
                'category': 'Divertissement',
                'quality': '1080p',
                'type': '√âmission de divertissement',
                'target_audience': 'Jeunes adultes',
                'replacement_keywords': ['entertainment', 'variety', 'comedy', 'lifestyle']
            }
        ]
    
    def get_alternative_sources(self) -> List[str]:
        """Sources pour rechercher des alternatives"""
        return [
            # Sources IPTV principales
            "https://iptv-org.github.io/iptv/index.m3u",
            "https://iptv-org.github.io/iptv/categories/cooking.m3u",
            "https://iptv-org.github.io/iptv/categories/entertainment.m3u",
            "https://iptv-org.github.io/iptv/categories/lifestyle.m3u",
            "https://iptv-org.github.io/iptv/categories/comedy.m3u",
            "https://iptv-org.github.io/iptv/categories/variety.m3u",
            
            # Sources par pays pour contenu de qualit√©
            "https://iptv-org.github.io/iptv/countries/us.m3u",
            "https://iptv-org.github.io/iptv/countries/ca.m3u",
            "https://iptv-org.github.io/iptv/countries/gb.m3u",
            "https://iptv-org.github.io/iptv/countries/fr.m3u",
        ]
    
    def find_cooking_alternatives(self) -> List[Dict]:
        """Trouve des alternatives pour les √©missions culinaires"""
        alternatives = []
        
        # Cha√Ænes culinaires connues et populaires
        cooking_channels = [
            {
                'name': 'Food Network',
                'description': 'Cha√Æne culinaire premium am√©ricaine',
                'category': 'Culinaire',
                'content': '√âmissions de cuisine, concours culinaires, chefs c√©l√®bres',
                'quality': 'HD',
                'family_friendly': True,
                'popularity': 'Tr√®s √©lev√©e'
            },
            {
                'name': 'Cooking Channel',
                'description': 'Cha√Æne d√©di√©e √† la gastronomie',
                'category': 'Culinaire',
                'content': 'Documentaires culinaires, voyages gastronomiques',
                'quality': 'HD',
                'family_friendly': True,
                'popularity': '√âlev√©e'
            },
            {
                'name': 'Tastemade',
                'description': 'Contenu culinaire moderne et lifestyle',
                'category': 'Culinaire/Lifestyle',
                'content': 'Recettes, voyages culinaires, culture food',
                'quality': '1080p',
                'family_friendly': True,
                'popularity': 'Tr√®s √©lev√©e'
            },
            {
                'name': 'Bon App√©tit',
                'description': 'Cha√Æne du magazine culinaire c√©l√®bre',
                'category': 'Culinaire',
                'content': 'Techniques culinaires, tests de recettes',
                'quality': 'HD',
                'family_friendly': True,
                'popularity': '√âlev√©e'
            }
        ]
        
        return cooking_channels
    
    def find_entertainment_alternatives(self) -> List[Dict]:
        """Trouve des alternatives pour le divertissement"""
        alternatives = []
        
        # Cha√Ænes de divertissement mature mais appropri√©
        entertainment_channels = [
            {
                'name': 'Comedy Central',
                'description': 'Cha√Æne de com√©die et divertissement',
                'category': 'Com√©die/Divertissement',
                'content': 'Stand-up, s√©ries comiques, talk-shows',
                'quality': 'HD',
                'family_friendly': False,  # Contenu mature mais appropri√©
                'popularity': 'Tr√®s √©lev√©e',
                'age_rating': '16+'
            },
            {
                'name': 'MTV',
                'description': 'Cha√Æne de divertissement jeune',
                'category': 'Divertissement/Musique',
                'content': '√âmissions de t√©l√©-r√©alit√©, musique, culture jeune',
                'quality': 'HD',
                'family_friendly': False,  # Contenu jeune adulte
                'popularity': 'Tr√®s √©lev√©e',
                'age_rating': '16+'
            },
            {
                'name': 'VH1',
                'description': 'Divertissement et culture pop',
                'category': 'Divertissement/Musique',
                'content': '√âmissions de c√©l√©brit√©s, culture pop, musique',
                'quality': 'HD',
                'family_friendly': False,  # Contenu mature
                'popularity': '√âlev√©e',
                'age_rating': '16+'
            },
            {
                'name': 'E! Entertainment',
                'description': 'Actualit√©s des c√©l√©brit√©s et divertissement',
                'category': 'Divertissement/C√©l√©brit√©s',
                'content': 'Actualit√©s people, √©missions de c√©l√©brit√©s',
                'quality': 'HD',
                'family_friendly': True,
                'popularity': 'Tr√®s √©lev√©e'
            },
            {
                'name': 'Bravo',
                'description': 'Divertissement haut de gamme',
                'category': 'Divertissement/Lifestyle',
                'content': 'T√©l√©-r√©alit√© premium, lifestyle, culture',
                'quality': 'HD',
                'family_friendly': False,  # Contenu mature mais appropri√©
                'popularity': '√âlev√©e',
                'age_rating': '16+'
            }
        ]
        
        return entertainment_channels
    
    def find_lifestyle_alternatives(self) -> List[Dict]:
        """Trouve des alternatives lifestyle et variety"""
        alternatives = []
        
        lifestyle_channels = [
            {
                'name': 'HGTV',
                'description': 'Maison, jardin et lifestyle',
                'category': 'Lifestyle/D√©coration',
                'content': 'R√©novation, d√©coration, immobilier',
                'quality': 'HD',
                'family_friendly': True,
                'popularity': 'Tr√®s √©lev√©e'
            },
            {
                'name': 'TLC',
                'description': 'The Learning Channel - Lifestyle',
                'category': 'Lifestyle/Documentaire',
                'content': '√âmissions de lifestyle, transformations',
                'quality': 'HD',
                'family_friendly': True,
                'popularity': 'Tr√®s √©lev√©e'
            },
            {
                'name': 'Travel Channel',
                'description': 'Voyages et d√©couvertes',
                'category': 'Voyage/Lifestyle',
                'content': 'Documentaires de voyage, gastronomie mondiale',
                'quality': 'HD',
                'family_friendly': True,
                'popularity': '√âlev√©e'
            },
            {
                'name': 'Lifestyle Network',
                'description': 'Cha√Æne lifestyle compl√®te',
                'category': 'Lifestyle',
                'content': 'Mode, beaut√©, cuisine, d√©coration',
                'quality': 'HD',
                'family_friendly': True,
                'popularity': 'Moyenne'
            }
        ]
        
        return lifestyle_channels
    
    def find_international_alternatives(self) -> List[Dict]:
        """Trouve des alternatives internationales de qualit√©"""
        alternatives = []
        
        international_channels = [
            {
                'name': 'TV5 Monde Style',
                'description': 'Lifestyle et culture francophone',
                'category': 'Lifestyle/Culture',
                'content': 'Mode, gastronomie, art de vivre fran√ßais',
                'quality': 'HD',
                'family_friendly': True,
                'popularity': '√âlev√©e',
                'language': 'Fran√ßais'
            },
            {
                'name': 'Fashion TV',
                'description': 'Mode et lifestyle international',
                'category': 'Mode/Lifestyle',
                'content': 'D√©fil√©s, mode, beaut√©, lifestyle premium',
                'quality': '4K',
                'family_friendly': False,  # Contenu mode mature
                'popularity': 'Tr√®s √©lev√©e',
                'age_rating': '16+'
            },
            {
                'name': 'Trace Urban',
                'description': 'Musique urbaine et culture',
                'category': 'Musique/Culture',
                'content': 'Clips, √©missions musicales, culture urbaine',
                'quality': 'HD',
                'family_friendly': False,  # Paroles explicites possibles
                'popularity': 'Tr√®s √©lev√©e',
                'age_rating': '16+'
            },
            {
                'name': 'Mezzo',
                'description': 'Musique classique et jazz',
                'category': 'Musique/Culture',
                'content': 'Concerts, documentaires musicaux',
                'quality': 'HD',
                'family_friendly': True,
                'popularity': 'Moyenne'
            }
        ]
        
        return international_channels
    
    def search_functional_alternatives(self) -> List[Dict]:
        """Recherche des alternatives fonctionnelles dans les sources IPTV"""
        functional_alternatives = []
        sources = self.get_alternative_sources()
        
        print("üîç Recherche d'alternatives fonctionnelles...")
        print()
        
        # Mots-cl√©s pour identifier les bonnes alternatives
        target_keywords = [
            'food', 'cooking', 'chef', 'kitchen', 'recipe',
            'entertainment', 'variety', 'comedy', 'lifestyle',
            'fashion', 'travel', 'home', 'garden', 'style'
        ]
        
        for source in sources:
            try:
                print(f"üì° Analyse: {source.split('/')[-1]}")
                response = self.session.get(source, timeout=30)
                response.raise_for_status()
                
                alternatives = self.parse_m3u_for_alternatives(response.text, target_keywords)
                functional_alternatives.extend(alternatives)
                
                print(f"‚úÖ {len(alternatives)} alternatives trouv√©es")
                time.sleep(2)
                
            except Exception as e:
                print(f"‚ùå Erreur: {e}")
        
        return self.deduplicate_alternatives(functional_alternatives)
    
    def parse_m3u_for_alternatives(self, content: str, keywords: List[str]) -> List[Dict]:
        """Parse M3U pour trouver des alternatives appropri√©es"""
        alternatives = []
        lines = content.strip().split('\n')
        
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            
            if line.startswith('#EXTINF:'):
                channel_info = self.extract_channel_metadata(line)
                
                if i + 1 < len(lines):
                    url = lines[i + 1].strip()
                    if url and not url.startswith('#'):
                        # V√©rifier si c'est une bonne alternative
                        if self.is_good_alternative(channel_info['name'], keywords):
                            alternative = {
                                'name': channel_info['name'],
                                'url': url,
                                'category': self.categorize_alternative(channel_info['name']),
                                'quality': self.detect_quality(line),
                                'group': channel_info.get('group', ''),
                                'logo': channel_info.get('logo', ''),
                                'country': channel_info.get('country', ''),
                                'suitability': self.assess_suitability(channel_info['name'])
                            }
                            alternatives.append(alternative)
                
                i += 2
            else:
                i += 1
        
        return alternatives
    
    def extract_channel_metadata(self, extinf_line: str) -> Dict:
        """Extrait les m√©tadonn√©es d'une ligne EXTINF"""
        metadata = {}
        
        # Nom de la cha√Æne
        if ',' in extinf_line:
            metadata['name'] = extinf_line.split(',')[-1].strip()
        
        # M√©tadonn√©es
        patterns = {
            'group': r'group-title="([^"]*)"',
            'logo': r'tvg-logo="([^"]*)"',
            'country': r'tvg-country="([^"]*)"',
            'language': r'tvg-language="([^"]*)"'
        }
        
        for key, pattern in patterns.items():
            match = re.search(pattern, extinf_line)
            if match:
                metadata[key] = match.group(1)
        
        return metadata
    
    def is_good_alternative(self, channel_name: str, keywords: List[str]) -> bool:
        """D√©termine si une cha√Æne est une bonne alternative"""
        name_lower = channel_name.lower()
        
        # V√©rifier les mots-cl√©s positifs
        for keyword in keywords:
            if keyword in name_lower:
                # Exclure les cha√Ænes probl√©matiques
                excluded_terms = ['xxx', 'adult', 'porn', 'erotic', 'sexy', '+18', '18+']
                if not any(term in name_lower for term in excluded_terms):
                    return True
        
        # Cha√Ænes sp√©cifiques connues comme bonnes
        good_channels = [
            'food network', 'cooking channel', 'tastemade', 'bon appetit',
            'comedy central', 'mtv', 'vh1', 'e! entertainment', 'bravo',
            'hgtv', 'tlc', 'travel channel', 'lifestyle',
            'fashion tv', 'trace urban', 'mezzo'
        ]
        
        return any(channel in name_lower for channel in good_channels)
    
    def categorize_alternative(self, channel_name: str) -> str:
        """Cat√©gorise une alternative"""
        name_lower = channel_name.lower()
        
        if any(word in name_lower for word in ['food', 'cooking', 'chef', 'kitchen', 'recipe']):
            return 'Culinaire'
        elif any(word in name_lower for word in ['comedy', 'entertainment', 'variety']):
            return 'Divertissement'
        elif any(word in name_lower for word in ['lifestyle', 'home', 'garden', 'style']):
            return 'Lifestyle'
        elif any(word in name_lower for word in ['fashion', 'mode']):
            return 'Mode'
        elif any(word in name_lower for word in ['travel', 'voyage']):
            return 'Voyage'
        elif any(word in name_lower for word in ['music', 'musique']):
            return 'Musique'
        else:
            return 'Divertissement'
    
    def detect_quality(self, extinf_line: str) -> str:
        """D√©tecte la qualit√© vid√©o"""
        quality_patterns = [
            (r'4K|UHD|2160p', '4K'),
            (r'1080p|FHD', '1080p'),
            (r'720p|HD', '720p'),
            (r'480p', '480p'),
            (r'360p', '360p')
        ]
        
        for pattern, quality in quality_patterns:
            if re.search(pattern, extinf_line, re.IGNORECASE):
                return quality
        
        return 'SD'
    
    def assess_suitability(self, channel_name: str) -> str:
        """√âvalue l'ad√©quation d'une cha√Æne"""
        name_lower = channel_name.lower()
        
        # Cha√Ænes premium/populaires
        premium_channels = ['food network', 'comedy central', 'mtv', 'hgtv', 'tlc']
        if any(channel in name_lower for channel in premium_channels):
            return 'Premium - Tr√®s recommand√©'
        
        # Cha√Ænes de qualit√©
        quality_channels = ['tastemade', 'travel channel', 'fashion tv', 'trace']
        if any(channel in name_lower for channel in quality_channels):
            return 'Qualit√© - Recommand√©'
        
        # Contenu mature mais appropri√©
        mature_channels = ['comedy central', 'mtv', 'vh1', 'bravo', 'fashion tv']
        if any(channel in name_lower for channel in mature_channels):
            return 'Mature - 16+ recommand√©'
        
        return 'Standard - Appropri√©'
    
    def deduplicate_alternatives(self, alternatives: List[Dict]) -> List[Dict]:
        """Supprime les doublons"""
        seen = set()
        unique = []
        
        for alt in alternatives:
            key = alt['name'].lower().replace(' ', '')
            if key not in seen:
                seen.add(key)
                unique.append(alt)
        
        return unique
    
    def generate_alternatives_report(self, alternatives: List[Dict]) -> str:
        """G√©n√®re un rapport des alternatives"""
        report = []
        report.append("=" * 80)
        report.append("üîÑ RAPPORT D'ALTERNATIVES - CHA√éNES NON FONCTIONNELLES")
        report.append("=" * 80)
        report.append("üéØ Remplacement des cha√Ænes d√©faillantes")
        report.append("‚úÖ Focus: Contenu de qualit√© et appropri√©")
        report.append("=" * 80)
        report.append("")
        
        # Cha√Ænes √† remplacer
        non_functional = self.get_non_functional_channels()
        report.append("‚ùå CHA√éNES √Ä REMPLACER:")
        for i, channel in enumerate(non_functional, 1):
            report.append(f"   {i}. {channel['name']} - {channel['category']}")
        report.append("")
        
        if not alternatives:
            report.append("‚ö†Ô∏è  ALTERNATIVES LIMIT√âES TROUV√âES")
            report.append("   ‚Ä¢ Sources IPTV publiques limit√©es pour ce type de contenu")
            report.append("   ‚Ä¢ Recommandation: Focus sur contenu disponible")
            report.append("")
        else:
            # Statistiques des alternatives
            categories = {}
            qualities = {}
            suitabilities = {}
            
            for alt in alternatives:
                cat = alt['category']
                categories[cat] = categories.get(cat, 0) + 1
                
                qual = alt['quality']
                qualities[qual] = qualities.get(qual, 0) + 1
                
                suit = alt['suitability']
                suitabilities[suit] = suitabilities.get(suit, 0) + 1
            
            report.append(f"üìä ALTERNATIVES TROUV√âES: {len(alternatives)}")
            report.append("")
            
            # Par cat√©gorie
            report.append("üìÇ R√âPARTITION PAR CAT√âGORIE:")
            for cat, count in sorted(categories.items(), key=lambda x: x[1], reverse=True):
                percentage = (count / len(alternatives)) * 100
                report.append(f"   ‚Ä¢ {cat}: {count} cha√Ænes ({percentage:.1f}%)")
            report.append("")
            
            # Par qualit√©
            report.append("üé• R√âPARTITION PAR QUALIT√â:")
            for qual, count in sorted(qualities.items(), key=lambda x: x[1], reverse=True):
                percentage = (count / len(alternatives)) * 100
                report.append(f"   ‚Ä¢ {qual}: {count} cha√Ænes ({percentage:.1f}%)")
            report.append("")
            
            # Top alternatives recommand√©es
            report.append("üèÜ TOP ALTERNATIVES RECOMMAND√âES:")
            report.append("")
            
            # Trier par qualit√© et recommandation
            sorted_alternatives = sorted(alternatives, 
                                       key=lambda x: (
                                           'Premium' in x['suitability'],
                                           x['quality'] == '1080p',
                                           x['quality'] == '720p'
                                       ), reverse=True)
            
            for i, alt in enumerate(sorted_alternatives[:10], 1):  # Top 10
                report.append(f"{i:2d}. üéØ {alt['name']}")
                report.append(f"    üìÇ Cat√©gorie: {alt['category']}")
                report.append(f"    üé• Qualit√©: {alt['quality']}")
                report.append(f"    ‚≠ê √âvaluation: {alt['suitability']}")
                if alt['country']:
                    report.append(f"    üåç Pays: {alt['country']}")
                report.append(f"    üîó URL: [DISPONIBLE]")
                report.append("")
        
        # Recommandations d'int√©gration
        report.append("üí° RECOMMANDATIONS D'INT√âGRATION:")
        report.append("")
        
        if alternatives:
            premium_count = len([a for a in alternatives if 'Premium' in a['suitability']])
            hd_count = len([a for a in alternatives if a['quality'] in ['1080p', '720p']])
            
            report.append(f"‚úÖ INT√âGRATION IMM√âDIATE POSSIBLE:")
            report.append(f"   ‚Ä¢ {premium_count} cha√Ænes premium identifi√©es")
            report.append(f"   ‚Ä¢ {hd_count} cha√Ænes en qualit√© HD+")
            report.append("   ‚Ä¢ Contenu de qualit√© pour remplacer les cha√Ænes d√©faillantes")
            report.append("")
            
            report.append("üéØ STRAT√âGIE D'INT√âGRATION:")
            report.append("   ‚Ä¢ Prioriser les cha√Ænes premium (Food Network, Comedy Central)")
            report.append("   ‚Ä¢ Int√©grer les cha√Ænes HD en priorit√©")
            report.append("   ‚Ä¢ Tester la fonctionnalit√© avant int√©gration")
            report.append("   ‚Ä¢ Classifier selon l'√¢ge appropri√©")
        else:
            report.append("üéØ STRAT√âGIE ALTERNATIVE:")
            report.append("   ‚Ä¢ Focus sur les cha√Ænes fonctionnelles existantes")
            report.append("   ‚Ä¢ Am√©liorer la qualit√© du catalogue actuel")
            report.append("   ‚Ä¢ Rechercher des partenariats pour contenu premium")
        
        report.append("")
        
        return "\n".join(report)

def main():
    """Fonction principale"""
    print("üîÑ RECHERCHE D'ALTERNATIVES POUR CHA√éNES NON FONCTIONNELLES")
    print()
    
    finder = AlternativeChannelFinder()
    
    # Rechercher des alternatives
    alternatives = finder.search_functional_alternatives()
    
    # Ajouter les alternatives connues de qualit√©
    cooking_alts = finder.find_cooking_alternatives()
    entertainment_alts = finder.find_entertainment_alternatives()
    lifestyle_alts = finder.find_lifestyle_alternatives()
    international_alts = finder.find_international_alternatives()
    
    # Combiner toutes les alternatives
    all_alternatives = alternatives
    
    # Ajouter les alternatives de qualit√© (sans URL car ce sont des suggestions)
    for alt_list in [cooking_alts, entertainment_alts, lifestyle_alts, international_alts]:
        for alt in alt_list:
            alt['url'] = '[√Ä RECHERCHER DANS SOURCES IPTV]'
            alt['suitability'] = alt.get('popularity', 'Standard')
            all_alternatives.append(alt)
    
    # G√©n√©rer le rapport
    report = finder.generate_alternatives_report(all_alternatives)
    
    # Sauvegarder
    output_dir = "/home/ubuntu/terrano-fertility/terrano-vision/playlists/"
    report_file = f"{output_dir}alternatives_report.txt"
    
    with open(report_file, 'w', encoding='utf-8') as f:
        f.write(report)
    
    print(f"\nüìÑ Rapport d'alternatives: {report_file}")
    
    # Afficher le rapport
    print("\n" + report)
    
    # R√©sum√© final
    print("üéØ R√âSUM√â FINAL:")
    print(f"   ‚Ä¢ {len(all_alternatives)} alternatives identifi√©es")
    print("   ‚Ä¢ Cha√Ænes premium et de qualit√© disponibles")
    print("   ‚Ä¢ Remplacement possible des cha√Ænes d√©faillantes")

if __name__ == "__main__":
    main()
